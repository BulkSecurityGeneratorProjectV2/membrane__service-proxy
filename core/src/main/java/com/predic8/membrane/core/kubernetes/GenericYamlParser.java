package com.predic8.membrane.core.kubernetes;

import com.predic8.membrane.annot.MCAttribute;
import com.predic8.membrane.annot.MCChildElement;
import com.predic8.membrane.core.config.spring.K8sHelperGeneratorAutoGenerated;
import org.jose4j.json.internal.json_simple.JSONArray;
import org.jose4j.json.internal.json_simple.JSONObject;
import org.yaml.snakeyaml.events.*;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;

import static com.predic8.membrane.core.config.spring.k8s.YamlLoader.readObj;
import static com.predic8.membrane.core.config.spring.k8s.YamlLoader.readString;

public class GenericYamlParser {
    @SuppressWarnings({"unchecked", "rawtypes"})
    public static <T> T parse(Class<T> clazz, Iterator<Event> events) {
        T obj = null;
        try {
            obj = clazz.newInstance();
            Event event = events.next();
            if (!(event instanceof MappingStartEvent)) {
                throw new IllegalStateException("Expected start-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
            }
            while(true) {
                event = events.next();
                String key;
                if (event instanceof ScalarEvent) {
                    key = ((ScalarEvent)event).getValue();
                } else if (event instanceof MappingEndEvent) {
                    break;
                } else {
                    throw new IllegalStateException("Expected scalar or end-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
                }
                Method setter = getSetter(clazz, key);

                Class wanted = setter.getParameterTypes()[0];
                if (wanted.equals(List.class)) {
                    setSetter(obj, setter, parseList(events));
                } else if (wanted.equals(String.class)) {
                    setSetter(obj, setter, readString(events));
                } else if (wanted.equals(Integer.TYPE)) {
                    setSetter(obj, setter, Integer.parseInt(readString(events)));
                } else if (isStructured(setter)) {
                    setSetter(obj, setter, parse(wanted, events));
                } else {
                    throw new RuntimeException("Not implemented setter type " + wanted);
                }
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }

        return obj;
    }

    private static List parseList(Iterator<Event> events) {
        Event event = events.next();
        if (!(event instanceof SequenceStartEvent)) {
            throw new IllegalStateException("Expected start-of-sequence in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        }
        ArrayList res = new ArrayList();
        while (true) {
            event = events.next();
            if (event instanceof SequenceEndEvent)
                break;
            else if (!(event instanceof MappingStartEvent))
                throw new IllegalStateException("Expected end-of-sequence or begin-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
            Object o = parseMapToObj(events);
            res.add(o);
        }

        return res;
    }

    private static Object parseMapToObj(Iterator<Event> events) {
        Event event = events.next();
        if (!(event instanceof ScalarEvent))
            throw new IllegalStateException("Expected scalar in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        String key = ((ScalarEvent)event).getValue();
        Class clazz = K8sHelperGeneratorAutoGenerated.elementMapping.get(key);
        if (clazz == null)
            throw new RuntimeException("Did not find java class for key '" + key + "'.");
        Object o = GenericYamlParser.parse(clazz, events);
        event = events.next();
        if (!(event instanceof MappingEndEvent))
            throw new IllegalStateException("Expected end-of-map or begin-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        return o;
    }

    private static <T> Method getSetter(Class<T> clazz, String key) {
        return Arrays.stream(clazz.getMethods())
                .filter(GenericYamlParser::isSetter)
                .filter(method -> matchesJsonKey(method, key))
                .findFirst()
                .orElseThrow(() ->
                        new RuntimeException("Can't find method for key: " + key + " in " + clazz.getName()));
    }

    private static <T> void setSetter(T instance, Method method, Object value) throws InvocationTargetException, IllegalAccessException {
        method.invoke(instance, value);
    }

    private static boolean isStructured(Method method) {
        return method.isAnnotationPresent(MCChildElement.class);
    }

    private static boolean isCollection(Method method) {
        return Arrays.asList(method.getParameterTypes()).contains(List.class);
    }

    private static boolean isSetter(Method method) {
        return method.getName().startsWith("set");
    }

    private static boolean matchesJsonKey(Method method, String key) {
        return method.getName().substring(3).equalsIgnoreCase(key) || equalsAttributeName(method, key);
    }

    private static boolean equalsAttributeName(Method method, String key) {
        if (!method.isAnnotationPresent(MCAttribute.class))
            return false;
        return method.getAnnotation(MCAttribute.class).attributeName().equals(key);
    }

}